datapts$alt <- anidf$Altitude
sp::coordinates(datapts) <- ~x+y
datapts_elev <- nabor::knn(sp::coordinates(elevpts), sp::coordinates(datapts), k=1)
anidf$Elevation <- elevpts$layer[ datapts_elev$nn.idx]
return(anidf)
}
xelev <-lookup_elevations(demo)
View(xelev)
xelev <-lookup_elevations(demo, zoom=12)
hist(xelev$Elevation)
summary(xelev$Elevation)
lookup_elevations <- function(anidf, zoom = 10) {
locations <- anidf %>%
select(x = Longitude, y = Latitude)
elev <- elevatr::get_elev_raster(locations, prj = "+proj=longlat", z=zoom)
elevpts <- raster::rasterToPoints(elev, spatial=TRUE) # convert to spatial pts
datapts <- rgdal::project(as.matrix(locations), raster::projection(elevpts))
datapts <- as.data.frame(datapts)
# datapts$alt <- anidf$Altitude
sp::coordinates(datapts) <- ~x+y
print(head(datapts))
datapts_elev <- nabor::knn(sp::coordinates(elevpts), sp::coordinates(datapts), k=1)
anidf$Elevation <- elevpts$layer[ datapts_elev$nn.idx]
return(anidf)
}
xelev <-lookup_elevations(demo, zoom=12)
nabor::knn
?nabor::knn
head(sp::coordinates(elevpts))
lookup_elevations <- function(anidf, zoom = 10) {
locations <- anidf %>%
select(x = Longitude, y = Latitude)
elev <- elevatr::get_elev_raster(locations, prj = "+proj=longlat", z=zoom)
elevpts <- raster::rasterToPoints(elev, spatial=TRUE) # convert to spatial pts
datapts_elev <- nabor::knn(elevpts, locations, k=1)
anidf$Elevation <- elevpts$layer[ datapts_elev$nn.idx]
return(anidf)
}
xelev <-lookup_elevations(demo, zoom=12)
head(sp::coordinates(elevpts))
ookup_elevations <- function(anidf, zoom = 10) {
locations <- anidf %>%
select(x = Longitude, y = Latitude)
elev <- elevatr::get_elev_raster(locations, prj = "+proj=longlat", z=zoom)
elevpts <- raster::rasterToPoints(elev, spatial=TRUE) # convert to spatial pts
datapts_elev <- nabor::knn(data = sp::coordinates(elevpts), query = locations, k=1)
anidf$Elevation <- elevpts$layer[ datapts_elev$nn.idx]
return(anidf)
}
xelev <-lookup_elevations(demo, zoom=12)
lookup_elevations <- function(anidf, zoom = 10) {
locations <- anidf %>%
select(x = Longitude, y = Latitude)
elev <- elevatr::get_elev_raster(locations, prj = "+proj=longlat", z=zoom)
elevpts <- raster::rasterToPoints(elev, spatial=TRUE) # convert to spatial pts
datapts_elev <- nabor::knn(data = sp::coordinates(elevpts), query = locations, k=1)
anidf$Elevation <- elevpts$layer[ datapts_elev$nn.idx]
return(anidf)
}
xelev <-lookup_elevations(demo, zoom=12)
hist(xelev$Elevation-xelev$Altitude)
psych::describe(xelev$Elevation-xelev$Altitude)
hist(xelev$Elevation)
hist(xelev$Altitude)
plot(xelev$Altitude, xelev$Elevation)
xelev <- lookup_elevations(demo, zoom = 12)
histogram_animal_elevation <- function(datapts) {
histogram <- ggplot(datapts, aes(x = Elevation - Altitude)) +
xlim(-100,100)+
geom_histogram(aes(y=..density..), colour="blue", fill="lightblue", binwidth = 2 )+
geom_density(alpha=.2, fill="#FF6666") +
geom_vline(aes(xintercept = mean((Elevation-Altitude)[abs(Elevation-Altitude) <= 100])),col='blue',size=2)+
labs(title = "Distribution of Modeled Elevation - Measured Altitude (meters)")+
theme_minimal()
return(histogram)
}
histogram_animal_elevation(xelev)
histogram_animal_elevation <- function(datapts) {
histogram <- ggplot2::ggplot(datapts, aes(x = Elevation - Altitude)) +
xlim(-100,100)+
geom_histogram(aes(y=..density..), colour="blue", fill="lightblue", binwidth = 2 )+
geom_density(alpha=.2, fill="#FF6666") +
geom_vline(aes(xintercept = mean((Elevation-Altitude)[abs(Elevation-Altitude) <= 100])),col='blue',size=2)+
labs(title = "Distribution of Modeled Elevation - Measured Altitude (meters)")+
theme_minimal()
return(histogram)
}
histogram_animal_elevation(xelev)
histogram_animal_elevation <- function(datapts) {
require(ggplot2)
histogram <- ggplot(datapts, aes(x = Elevation - Altitude)) +
xlim(-100,100)+
geom_histogram(aes(y=..density..), colour="blue", fill="lightblue", binwidth = 2 )+
geom_density(alpha=.2, fill="#FF6666") +
geom_vline(aes(xintercept = mean((Elevation-Altitude)[abs(Elevation-Altitude) <= 100])),col='blue',size=2)+
labs(title = "Distribution of Modeled Elevation - Measured Altitude (meters)")+
theme_minimal()
return(histogram)
}
histogram_animal_elevation(xelev)
xelev <- lookup_elevations(demo, zoom = 10)
histogram_animal_elevation(xelev)
devtools::install_github("mathedjoe/animaltracker"); library(animaltracker);
devtools::build()
devtools::load()
devtools::load_all()
devtools::build(manual=TRUE)
devtools::build(manual=TRUE, binary=TRUE)
devtools::build(binary= TRUE, manual=TRUE)
devtools::load_all()
run_shiny_animaltracker()
devtools::load_all()
run_shiny_animaltracker()
devtools::load_all()
run_shiny_animaltracker()
devtools::load_all()
run_shiny_animaltracker()
clean_df <- function(df, ani_id, gps_id) {
timezone <- "UTC"
window <- list(latmax = 43.3464, lonmin = -117.2305, latmin = 43.2472, lonmax=-117.101 )
nstart <- nrow(df)
### REMOVE BAD DATA POINTS (as described on pages 26-39 of Word Doc)
df<- df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = ani_id, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gps_id, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) %>% #compute geodesic distance between points
dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
Latitude!=0, Longitude !=0,
TimeDiffMins < 100,
Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
Latitude >= window$latmin,  Latitude <= window$latmax,
Longitude >= window$lonmin,  Longitude <= window$lonmax,
!DistanceFlag )
# add elevation data
df <- lookup_elevation()
return(df)
}
clean_locations<- function (df){
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
clean_locations<- function (df){
require(dplyr)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
clean_locations<- function (df){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
clean_locations<- function (df, aniid, gpsid){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest, 99, 100)
clean_locations<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
summary(xx)
install.packages("forecast")
library(forecast)
xx %>%
tsclean() %>%
autoplot()
names(xx)
xx$Latitude %>%
tsclean() %>%
autoplot()
xx %>%
select(x = Date, y = Latitude) %>%
autoplot()
?autoplot
library(ggplot2)
ggplot( xx %>%
select(Date, Latitude) ) +
geom_line()
ggplot( xx %>%
select(x = Date, y = Latitude) , aes(x = x, y=y) ) +
geom_line()
?tsclean
zz <- tsclean(xx$Latitude)
plot(zz)
zz <- tsclean(xx$Latitude)
length(zz)
nrow(xx)
?tsoutliers
yy<- tsoutliers(xx$Latitude)
names(yy)
head(yy$index)
clean_locations<- function (df, aniid = NA, gpsid = NA, timezone = "UTC", window =  list(latmax = 43.3464, lonmin = -117.2305, latmin = 43.2472, lonmax=-117.101 )){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) %>% #compute geodesic distance between points
dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
Latitude!=0, Longitude !=0,
TimeDiffMins < 100,
Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
Latitude >= window$latmin,  Latitude <= window$latmax,
Longitude >= window$lonmin,  Longitude <= window$lonmax,
!DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
clean_locations_auto<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(
Latitude = forecast::tsclean(Latitude),
Longitude = forecast::tsclean(Longitude),
Altitude = forecast::tsclean(Altitude),
Rate = forecast::tsclean(Rate),
Distance = forecast::tsclean(Distance)
) %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) %>%
#compute geodesic distance between points
dplyr::mutate(
RateFlag = 1*(Rate > 84), # flag any data points representing too fast travel
CourseFlag = 1*(CourseDiff >= 100) ,
DistanceFlag = 1*(DistGeo >= 840 ),
TotalFlags = RateFlag + CourseFlag + DistanceFlag
) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
TimeDiffMins < 100,
!DistanceFlag )
}
xx2 <- clean_locations_auto(dftest)
summary(dftest)
clean_locations_auto<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(
Latitude = forecast::tsclean(Latitude),
Longitude = forecast::tsclean(Longitude),
Altitude = forecast::tsclean(Altitude),
Distance = forecast::tsclean(Distance),
Animal = as.factor(Animal), # reclassify Animal column as a categorical (factor) variable
DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone), # reclassify Date as a Date variable
Date = as.Date(Date, "%Y/%m/%d"), # reclassify Date as a Date variable
TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1)), # compute sequential time differences (in seconds)
TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")), # compute sequential time differences (in mins)
Rate = Distance/TimeDiffMins, # compute rate of travel (meters/min),
CourseDiff = abs(Course - dplyr::lag(Course,1)),
DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1) )), #compute geodesic distance between points
RateFlag = 1*(Rate > 84), # flag any data points representing too fast travel
CourseFlag = 1*(CourseDiff >= 100) ,
DistanceFlag = 1*(DistGeo >= 840 ),
TotalFlags = RateFlag + CourseFlag + DistanceFlag
) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
TimeDiffMins < 100,
!DistanceFlag )
}
xx2 <- clean_locations_auto(dftest)
nrow(xx2)
nrow(xx)
library(devtools)
document()
load_all()
dev_add_to_gitignore()
dev_add_to_gitignore("")
dev_add_to_gitignore("data"
)
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
install.packages("devtools")
library(devtools)
install_github("mathedjoe/animaltracker")
install_github("mathedjoe/animaltracker")
