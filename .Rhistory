observeEvent(input$validateButton, {
filestr <- input$csvInput
if(is.null(filestr)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
### Validating
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
output$flags <- renderTable(
out_df
)
}
}) #observeEvent
output$download <- downloadHandler(
filename = function() {
paste0(tools::file_path_sans_ext(filestr$datapath), "-flags", ".csv", sep="")
},
content = function(file) {
filestr <- input$csvInput
if(is.null(filestr)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
write.csv(out_df, file)
}
} #content
) #downloadHandler
} #server
shinyApp(ui = ui, server = server)
} #app
run_birdproofr_app()
run_birdproofr_app()
#'
#'Runs birdproofr Shiny app
#'
run_birdproofr_app <- function() {
ui <- fluidPage(
titlePanel("birdproofr"),
sidebarLayout(
sidebarPanel(
fileInput("csvInput", "Upload (.csv)", accept=c("text/csv","text/comma-separated-values",".csv")),
#selectInput("birdInput", "Bird", choices = c("Songbird", "Hummingbird")),
actionButton("validateButton", "Show Flags"),
downloadButton("download", "Download Flags (.csv)")
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Data", tableOutput("data")),
tabPanel("Flagged Issues", tableOutput("flags"))
) #tabsetPanel
) #mainPanel
)#sidebarLayout
) #ui
server <- function(input, output) {
observeEvent(input$csvInput, {
filestr <- input$csvInput
output$data <- renderTable(
read.csv(filestr$datapath)
)
}) #observeEvent
observeEvent(input$validateButton, {
filestr <- input$csvInput
if(is.null(filestr)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
### Validating
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
output$flags <- renderTable(
out_df
)
}
}) #observeEvent
output$download <- downloadHandler(
filename = function() {
if(is.null(input$csvInput)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
filestr <- input$csvInput
paste0(tools::file_path_sans_ext(filestr$datapath), "-flags", ".csv", sep="")
}
},
content = function(file) {
if(is.null(input$csvInput)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
filestr <- input$csvInput
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
write.csv(out_df, file)
}
} #content
) #downloadHandler
} #server
shinyApp(ui = ui, server = server)
} #app
run_birdproofr_app()
#'
#'Runs birdproofr Shiny app
#'
run_birdproofr_app <- function() {
ui <- fluidPage(
titlePanel("birdproofr"),
sidebarLayout(
sidebarPanel(
fileInput("csvInput", "Upload (.csv)", accept=c("text/csv","text/comma-separated-values",".csv")),
#selectInput("birdInput", "Bird", choices = c("Songbird", "Hummingbird")),
actionButton("validateButton", "Show Flags"),
downloadButton("download", "Download Flags (.csv)")
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Data", tableOutput("data")),
tabPanel("Flagged Issues", tableOutput("flags"))
) #tabsetPanel
) #mainPanel
)#sidebarLayout
) #ui
server <- function(input, output) {
observeEvent(input$csvInput, {
filestr <- input$csvInput
output$data <- renderTable(
read.csv(filestr$datapath)
)
}) #observeEvent
observeEvent(input$validateButton, {
filestr <- input$csvInput
if(is.null(filestr)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
### Validating
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
output$flags <- renderTable(
out_df
)
}
}) #observeEvent
output$download <- downloadHandler(
filename = function() {
if(is.null(input$csvInput)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
filestr <- input$csvInput
paste(tools::file_path_sans_ext(filestr$datapath), "-flags", ".csv", sep="")
}
},
content = function(file) {
if(is.null(input$csvInput)) {
showModal(modalDialog(
title = "File Not Found",
paste0("Please upload a CSV file before validating."),
easyClose = TRUE,
footer = NULL
))
}
else {
filestr <- input$csvInput
in_df <- read.csv(filestr$datapath, na.strings=c("", " "), header = TRUE)
colnames(in_df)[colnames(in_df) == "Original.Order.on.hard.copy"] <- "Order"
colnames(in_df)[colnames(in_df) == "proofing.and.data.entry.notes"] <- "Issue"
out_df <- data.frame()
to_validate <- validate_all_list(in_df)
for(df in to_validate) {
if(nrow(df) != 0) {
df <- subset(df, select=c(Order, Issue))
out_df <- rbind(out_df, df)
}
}
out_df <- out_df[order(out_df$Order),]
write.csv(out_df, file)
}
} #content
) #downloadHandler
} #server
shinyApp(ui = ui, server = server)
} #app
run_birdproofr_app()
setwd("animaltracker")
#'
#'You can run the animaltracker Shiny app by calling this function.
#'
#'@param rds_path Path of Animal data file to input
#'@export
run_shiny_animaltracker <- function(rds_path) {
require("shiny")
require("leaflet")
require("ggplot2")
# Load data
#suppressWarnings(ani <- dplyr::bind_rows(readRDS(rds_path)))
# Define UI for application that draws a histogram
ui <- fluidPage(
titlePanel("Animal Tracker App"),
sidebarLayout(
sidebarPanel(
fileInput("csvInput", "Upload (.csv)", accept=c("text/csv","text/comma-separated-values",".csv")),
submitButton("Submit File(s)")
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plots",  fluidRow(
column(4,
uiOutput("choose_dates"),
uiOutput("choose_data")),
column(8,
leafletOutput("mainmap", height = 640),
plotOutput("plot1"),
plotOutput("plot2")
)
)),
tabPanel("Statistics")
)
) #mainPanel
) #sidebarLayout
) #fluidPage
# Define server logic required to draw a histogram
server <- function(input, output, session) {
# print("got here")
# Drop-down selection box for which data set
output$choose_data<- renderUI({
checkboxGroupInput("selected_ani", "ani", choices = as.list(unique(ani$Animal)), selected = unique(ani$Animal)[1])
})
# date range
output$choose_dates <- renderUI({
# If missing input, return to avoid error later in function
if(is.null(input$selected_ani))
return()
# Get the data set with the appropriate name
dates <- ani %>%
filter(Animal %in% input$selected_ani)
dates <- dates$Date
sliderInput("dates", "Date Range", min = min(dates),
max = max(dates), value = c(min(dates), max(dates)), step = 1,
animate = animationOptions(loop = FALSE, interval = 1000))
})
dat <- reactive({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
ani %>%
filter(
Animal %in% input$selected_ani,
Date >= input$dates[1],
Date <= input$dates[2])
})
points <- reactive({
# If missing input, return to avoid error later in function
if(is.null(input$selected_ani) || is.null(input$dates) )
return()
SpatialPointsDataFrame(coords = dat()[c("Longitude", "Latitude")], data = dat(),
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
})
output$mainmap <- renderLeaflet({
if(is.null(input$selected_ani) || is.null(input$dates) )
return()
factpal <- colorFactor(hue_pal()(length(input$selected_ani)), input$selected_ani)
leaflet() %>%  # Add tiles
addTiles() %>%
# addProviderTiles("OpenTopoMap") %>%
addProviderTiles("Esri.WorldImagery", group = "Satellite") %>%
# addProviderTiles("Thunderforest.Landscape", group = "Topographical") %>%
# addProviderTiles("OpenStreetMap.Mapnik", group = "Road map") %>%
addCircleMarkers(data = points(), radius=6, fillOpacity = .6, stroke=F,
color = ~ factpal(Animal),
popup = ~ paste(paste("<h4>",paste("Animal ID:", points()$Animal), "</h4>"),
paste("Date/Time:", points()$DateTime),
paste("Altitude:", points()$Altitude),
paste("Elevation:", points()$Elevation),
paste("Lat/Lon:", paste(points()$Latitude, points()$Longitude, sep=", ")),
sep="<br/>")
)
# leaflet() %>%
#   addMarkers(data = points(),popup=as.character(points()$a))
})
output$plot1 <- renderPlot({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
# hist(dat()$TimeDiffMin [dat()$TimeDiffMin < 100], main = "Distribution of Time Between GPS Measurements" )
ggplot(dat(), aes(x=DateTime, y=Elevation, group=Animal, color=Animal)) +
labs( title = "Elevation (meters) during Data Collection")+
ylim(1000,2000)+geom_line() +
geom_point() +
theme_minimal()
})
output$plot2 <- renderPlot({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
ggplot(dat(), aes(x=TimeDiffMins, fill=Animal))+
geom_histogram(  col="White", breaks = seq(0,40, 2)) +
facet_wrap(~Animal, ncol=2)+
labs( title = "Distribution of Time between GPS Readings, by GPS Unit" )+
theme_minimal()
})
}
# Run the application
shinyApp(ui = ui, server = server)
}
run_shiny_animaltracker()
#'
#'You can run the animaltracker Shiny app by calling this function.
#'
#'@param rds_path Path of Animal data file to input
#'@export
run_shiny_animaltracker <- function() {
require("shiny")
require("leaflet")
require("ggplot2")
# Load data
#suppressWarnings(ani <- dplyr::bind_rows(readRDS(rds_path)))
# Define UI for application
ui <- fluidPage(
titlePanel("Animal Tracker App"),
sidebarLayout(
sidebarPanel(
fileInput("zipInput", "Upload (.zip of data directory)", accept=c(".zip")),
actionButton("process", "Process")
),
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("Plots",  fluidRow(
column(4,
uiOutput("choose_dates"),
uiOutput("choose_data")),
column(8,
leafletOutput("mainmap", height = 640),
plotOutput("plot1"),
plotOutput("plot2")
)
)),
tabPanel("Statistics")
)
) #mainPanel
) #sidebarLayout
) #fluidPage
# Define server logic required to draw a histogram
server <- function(input, output, session) {
# print("got here")
# Drop-down selection box for which data set
output$choose_data<- renderUI({
checkboxGroupInput("selected_ani", "ani", choices = as.list(unique(ani$Animal)), selected = unique(ani$Animal)[1])
})
# date range
output$choose_dates <- renderUI({
# If missing input, return to avoid error later in function
if(is.null(input$selected_ani))
return()
# Get the data set with the appropriate name
dates <- ani %>%
filter(Animal %in% input$selected_ani)
dates <- dates$Date
sliderInput("dates", "Date Range", min = min(dates),
max = max(dates), value = c(min(dates), max(dates)), step = 1,
animate = animationOptions(loop = FALSE, interval = 1000))
})
dat <- reactive({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
ani %>%
filter(
Animal %in% input$selected_ani,
Date >= input$dates[1],
Date <= input$dates[2])
})
points <- reactive({
# If missing input, return to avoid error later in function
if(is.null(input$selected_ani) || is.null(input$dates) )
return()
SpatialPointsDataFrame(coords = dat()[c("Longitude", "Latitude")], data = dat(),
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
})
output$mainmap <- renderLeaflet({
if(is.null(input$selected_ani) || is.null(input$dates) )
return()
factpal <- colorFactor(hue_pal()(length(input$selected_ani)), input$selected_ani)
leaflet() %>%  # Add tiles
addTiles() %>%
# addProviderTiles("OpenTopoMap") %>%
addProviderTiles("Esri.WorldImagery", group = "Satellite") %>%
# addProviderTiles("Thunderforest.Landscape", group = "Topographical") %>%
# addProviderTiles("OpenStreetMap.Mapnik", group = "Road map") %>%
addCircleMarkers(data = points(), radius=6, fillOpacity = .6, stroke=F,
color = ~ factpal(Animal),
popup = ~ paste(paste("<h4>",paste("Animal ID:", points()$Animal), "</h4>"),
paste("Date/Time:", points()$DateTime),
paste("Altitude:", points()$Altitude),
paste("Elevation:", points()$Elevation),
paste("Lat/Lon:", paste(points()$Latitude, points()$Longitude, sep=", ")),
sep="<br/>")
)
# leaflet() %>%
#   addMarkers(data = points(),popup=as.character(points()$a))
})
output$plot1 <- renderPlot({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
# hist(dat()$TimeDiffMin [dat()$TimeDiffMin < 100], main = "Distribution of Time Between GPS Measurements" )
ggplot(dat(), aes(x=DateTime, y=Elevation, group=Animal, color=Animal)) +
labs( title = "Elevation (meters) during Data Collection")+
ylim(1000,2000)+geom_line() +
geom_point() +
theme_minimal()
})
output$plot2 <- renderPlot({
if(is.null(input$selected_ani) || is.null(input$dates))
return()
ggplot(dat(), aes(x=TimeDiffMins, fill=Animal))+
geom_histogram(  col="White", breaks = seq(0,40, 2)) +
facet_wrap(~Animal, ncol=2)+
labs( title = "Distribution of Time between GPS Readings, by GPS Unit" )+
theme_minimal()
})
}
# Run the application
shinyApp(ui = ui, server = server)
}
run_shiny_animaltracker()
help(bind_rows)
run_shiny_animaltracker()
help("paste0")
i <- 0
