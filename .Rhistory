) ) %>% #compute geodesic distance between points
dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
Latitude!=0, Longitude !=0,
TimeDiffMins < 100,
Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
Latitude >= window$latmin,  Latitude <= window$latmax,
Longitude >= window$lonmin,  Longitude <= window$lonmax,
!DistanceFlag )
# add elevation data
df <- lookup_elevation()
return(df)
}
clean_locations<- function (df){
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
clean_locations<- function (df){
require(dplyr)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
clean_locations<- function (df){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv")
xx <- clean_locations(dftest)
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
clean_locations<- function (df, aniid, gpsid){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest, 99, 100)
clean_locations<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) #compute geodesic distance between points
# dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
# dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
# dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
# dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
# dplyr::filter(!is.na(DateTime), TotalFlags < 2,
#               Latitude!=0, Longitude !=0,
#               TimeDiffMins < 100,
#               Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
#               Latitude >= window$latmin,  Latitude <= window$latmax,
#               Longitude >= window$lonmin,  Longitude <= window$lonmax,
#               !DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
summary(xx)
install.packages("forecast")
library(forecast)
xx %>%
tsclean() %>%
autoplot()
names(xx)
xx$Latitude %>%
tsclean() %>%
autoplot()
xx %>%
select(x = Date, y = Latitude) %>%
autoplot()
?autoplot
library(ggplot2)
ggplot( xx %>%
select(Date, Latitude) ) +
geom_line()
ggplot( xx %>%
select(x = Date, y = Latitude) , aes(x = x, y=y) ) +
geom_line()
?tsclean
zz <- tsclean(xx$Latitude)
plot(zz)
zz <- tsclean(xx$Latitude)
length(zz)
nrow(xx)
?tsoutliers
yy<- tsoutliers(xx$Latitude)
names(yy)
head(yy$index)
clean_locations<- function (df, aniid = NA, gpsid = NA, timezone = "UTC", window =  list(latmax = 43.3464, lonmin = -117.2305, latmin = 43.2472, lonmax=-117.101 )){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) %>% #compute geodesic distance between points
dplyr::mutate(RateFlag = 1*(Rate > 84)) %>%  # flag any data points representing too fast travel
dplyr::mutate(CourseFlag = 1*(CourseDiff >= 100) ) %>%
dplyr::mutate(DistanceFlag = 1*(DistGeo >= 840 )) %>%
dplyr::mutate(TotalFlags = RateFlag + CourseFlag + DistanceFlag) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
Latitude!=0, Longitude !=0,
TimeDiffMins < 100,
Altitude > 2700/3.3, Altitude< 6000/3.3, # lower and upper limits (converted from feet to meters)
Latitude >= window$latmin,  Latitude <= window$latmax,
Longitude >= window$lonmin,  Longitude <= window$lonmax,
!DistanceFlag )
}
dftest <- read.csv("data/sample_location_data.csv", skipNul = T)
xx <- clean_locations(dftest)
clean_locations_auto<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(
Latitude = forecast::tsclean(Latitude),
Longitude = forecast::tsclean(Longitude),
Altitude = forecast::tsclean(Altitude),
Rate = forecast::tsclean(Rate),
Distance = forecast::tsclean(Distance)
) %>%
dplyr::mutate(Animal = as.factor(Animal))  %>%                     # reclassify Animal column as a categorical (factor) variable
dplyr::mutate(DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone)) %>%  # reclassify Date as a Date variable
dplyr::mutate(Date = as.Date(Date, "%Y/%m/%d"))  %>%            # reclassify Date as a Date variable
dplyr::mutate(TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1))) %>%  # compute sequential time differences (in seconds)
dplyr::mutate(TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")))  %>% # compute sequential time differences (in mins)
dplyr::mutate(Rate = Distance/TimeDiffMins) %>% # compute rate of travel (meters/min)
dplyr::mutate(CourseDiff = abs(Course - dplyr::lag(Course,1))) %>%
dplyr::mutate(DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1))
) ) %>%
#compute geodesic distance between points
dplyr::mutate(
RateFlag = 1*(Rate > 84), # flag any data points representing too fast travel
CourseFlag = 1*(CourseDiff >= 100) ,
DistanceFlag = 1*(DistGeo >= 840 ),
TotalFlags = RateFlag + CourseFlag + DistanceFlag
) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
TimeDiffMins < 100,
!DistanceFlag )
}
xx2 <- clean_locations_auto(dftest)
summary(dftest)
clean_locations_auto<- function (df, aniid = NA, gpsid = NA, timezone = "UTC"){
require(dplyr)
require(tibble)
df %>%
tibble::add_column(Order = df$Index, .before="Index")%>%  # add Order column
tibble::add_column(Animal = aniid, .after="Index") %>%      # add Animal column
tibble::add_column(GPS = gpsid, .after="Animal") %>%      # add Animal column
tibble::add_column(DateTime = NA, .after="GPS") %>%      # add Date/Time column
tibble::add_column(TimeDiff = NA, .after="DateTime") %>%
tibble::add_column(TimeDiffMins = NA, .after="TimeDiff") %>%
tibble::add_column(Rate = NA, .after="Distance") %>%
tibble::add_column(CourseDiff = NA, .after="Course") %>%
dplyr::mutate(
Latitude = forecast::tsclean(Latitude),
Longitude = forecast::tsclean(Longitude),
Altitude = forecast::tsclean(Altitude),
Distance = forecast::tsclean(Distance),
Animal = as.factor(Animal), # reclassify Animal column as a categorical (factor) variable
DateTime = as.POSIXct(paste(Date, Time), "%Y/%m/%d %H:%M:%S", tz=timezone), # reclassify Date as a Date variable
Date = as.Date(Date, "%Y/%m/%d"), # reclassify Date as a Date variable
TimeDiff = as.numeric(DateTime - dplyr::lag(DateTime,1)), # compute sequential time differences (in seconds)
TimeDiffMins = as.numeric(difftime(DateTime,dplyr::lag(DateTime,1), units="mins")), # compute sequential time differences (in mins)
Rate = Distance/TimeDiffMins, # compute rate of travel (meters/min),
CourseDiff = abs(Course - dplyr::lag(Course,1)),
DistGeo = geosphere::distGeo(cbind(Longitude, Latitude),
cbind(dplyr::lag(Longitude,1), dplyr::lag(Latitude, 1) )), #compute geodesic distance between points
RateFlag = 1*(Rate > 84), # flag any data points representing too fast travel
CourseFlag = 1*(CourseDiff >= 100) ,
DistanceFlag = 1*(DistGeo >= 840 ),
TotalFlags = RateFlag + CourseFlag + DistanceFlag
) %>%
dplyr::filter(!is.na(DateTime), TotalFlags < 2,
TimeDiffMins < 100,
!DistanceFlag )
}
xx2 <- clean_locations_auto(dftest)
nrow(xx2)
nrow(xx)
library(devtools)
document()
load_all()
dev_add_to_gitignore()
dev_add_to_gitignore("")
dev_add_to_gitignore("data"
)
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
library(devtools)
document()
build(manual=TRUE)
load_all()
run_shiny_animaltracker()
?addDrawToolbar
load_all()
?addDrawToolbar
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
document()
load_all()
library(devtools
)
load_all()
run_shiny_animaltracker()
library(devtools)
install_github("mathedjoe/animaltracker")
library(animaltracker)
run_shiny_animaltracker()
library(devtools)
load_all()
run_shiny_animaltracker()
library(devtools)
install_github("mathedjoe/animaltracker/dev")
install_github("mathedjoe/animaltracker", ref="dev")
library(animaltracker)
run_shiny_animaltracker()
library(devtools)
install_github("mathedjoe/animaltracker")
library(animaltracker)
run_shiny_animaltracker()
library(devtools)
load_all()
run_shiny_animaltracker()
library(animaltracker)
run_shiny_animaltracker()
library(devtools)
load_all()
run_shiny_animaltracker()
library(devtools)
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
?proxy
load_all()
run_shiny_animaltracker()
load_all()
run_shiny_animaltracker()
?addTiles
?tileOptions
load_all()
?tileOptions
load_all()
run_shiny_animaltracker()
library(devtools)
load_all()
run_shiny_animaltracker()
?read.csv
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T)
xx<- xx[,xx$Latitude!="Latitude"]
names(xx)
xx<- xx[xx$Latitude!="Latitude",]
nrow(xx)
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T)
nrow(xx)
xx<- xx[xx$Latitude!="Latitude",]
nrow(xx)
table(xx$Latitude)
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T)
nrow(xx)
View(xx)
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T
)
head(as.numeric(xx$Latitude))
head(as.numeric(xx$Latitude),12)
xx$Latitude <- as.numeric(xx$Latitude)
xx<- xx[!is.na(xx$Latitude),]
head(is.numeric(xx$Latitude),12)
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T)
head(is.numeric(xx$Latitude),12)
xx <- read.csv("data/dirty_sample_data.csv", skipNul = T, as.is=T)
xx$Latitude <- as.numeric(xx$Latitude)
xx<- xx[!is.na(xx$Latitude),]
nrow(xx)
library(devtools)
load_all()
run_shiny_animaltracker()
run_shiny_animaltracker()
install.packages(c("backports", "broom", "callr", "caTools", "clipr", "cowplot", "data.table", "dbplyr", "dbscan", "dplyr", "effects", "effsize", "evaluate", "forcats", "future", "future.apply", "geonames", "ggmap", "ggpubr", "ggsignif", "git2r", "gplots", "haven", "highcharter", "igraph", "irr", "jomo", "knitr", "labelled", "laeken", "later", "lattice", "lme4", "maptools", "mice", "mitml", "modelr", "openssl", "ordinal", "pracma", "processx", "ps", "psych", "purrr", "quantreg", "R.utils", "R6", "raster", "rcmdcheck", "RcppArmadillo", "RCurl", "readr", "readxl", "remotes", "rgdal", "RgoogleMaps", "rio", "rmarkdown", "rstudioapi", "sessioninfo", "sf", "shinyWidgets", "simglm", "simr", "spData", "stringi", "stringr", "survey", "sys", "tidyr", "tinytex", "VIM", "xfun", "XML", "zip"))
library("dplyr")
library(devtools); load_all();
run_shiny_animaltracker()
run_shiny_animaltracker()
library(devtools); load_all();
install.packages(c("V8", "shinyjs"))
library(devtools); load_all();
run_shiny_animaltracker()
library(shinyjs)
run_shiny_animaltracker()
fetch_temp_data <- function(test_data, radius, data_yrs){
require(GSODR)
require(dplyr)
data_yrs <- as.numeric(unique(format(data$Date, "%Y")))
find_nearest_data <- function( test_data, radius, year = data_yrs){
lat <- median(test_data$Latitude, na.rm = TRUE)
lon <- median(test_data$Longitude, na.rm = TRUE)
mystations <- nearest_stations(lat, lon, radius)
#   print(mystations)
dist <- 5
df_out <- get_GSOD (years = year, station = mystations[1], country = "US", CSV = FALSE)
for (stat in mystations){
df <- get_GSOD (years = year, station = stat, country = "US", CSV = FALSE)
lat_stat <- median(df$LAT, na.rm=T)
lon_stat <- median(df$LON, na.rm=T)
newdist <-sqrt((lat - lat_stat)^2+ (lon-lon_stat)^2)
print(c(stat, lat_stat, lon_stat, newdist))
if(newdist < dist){
print(paste(stat, "is the new closest stations"))
df_out <- df
dist <- newdist
#       print(newdist)
}
}
#    print(unique(df_out$STNID))
df_out
}
tempdata <- find_nearest_data(test_data, radius)
tempdata <- dplyr::bind_rows(tempdata, id = NULL)
print(names(tempdata))
# combine year, month and date into one column
tempdata$Date <-as.Date(paste0(tempdata$YEAR, "-", tempdata$MONTH, "-", tempdata$DAY))
temp_data <- subset(tempdata, select = c(2:5, 7:8, 18:19, 48))
names(temp_data)[3:8]<- paste0("STN_", names(temp_data)[3:8])
left_join(test_data, temp_data, by="Date")
}
library(devtools); load_all();
run_shiny_animaltracker()
